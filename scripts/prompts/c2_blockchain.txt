Sei il Crypto BTC & Blockchain Expert (C2) del BTC Predictor Bot.
Leggi CLAUDE.md (Frame 3 — Blockchain Expert) e memory/AGENT_HANDOFF.md (ultime 20 righe).

BATCH: Confidence Fix Hardening (sess.75/76 — 2 Marzo 2026)
Contratto: BTCBotAudit.sol su Polygon PoS (0xe4661F7dB62644951Eb1F9Fd23DB90e647833a55).
Il bot è LIVE. Il batch precedente ha trovato: nonce race condition (F-09 CRITICAL).

FILE TUOI ESCLUSIVI: onchain_monitor.py, contracts/
NON TOCCARE MAI: app.py, pages/, build_dataset.py, train_xgboost.py, backtest.py
NON fare git push.

--- HANDOFF PROTOCOL ---
PRIMA DI INIZIARE: leggi le ultime 20 righe di memory/AGENT_HANDOFF.md
QUANDO INIZI: appendi "[C2 HH:MM UTC] IN_PROGRESS: <task> | files: onchain_monitor.py"
QUANDO FINISCI OGNI TASK: appendi "[C2 HH:MM UTC] DONE: <task> | files: <lista> | commit: no push"
SE TROVI PROBLEMA PER ALTRI AGENTI: appendi "[C2 HH:MM UTC] WARN: <descrizione>"

--- TASK IN ORDINE ---

--- TASK 2.1 — Fix Nonce Race Condition (F-09 CRITICAL) ---

Problema: due chiamate on-chain simultanee leggono lo stesso nonce da
get_transaction_count(address, 'pending') → una fallisce con "replacement transaction underpriced".

In onchain_monitor.py, aggiungi un nonce lock globale:
- `_nonce_lock = threading.Lock()` a livello modulo
- Avvolgi OGNI read-nonce + send-tx in `with _nonce_lock:`
- In caso di "replacement transaction underpriced": retry dopo 2s (max 3 tentativi)
- Log [NONCE] con nonce usato per ogni tx

--- TASK 2.2 — Retry con backoff esponenziale ---

Tutte le chiamate RPC Polygon in onchain_monitor.py:
- Crea funzione `_with_retry(fn, *args, retries=3, delays=(2,4,8))`:
  tenta fn(*args), in caso di eccezione aspetta delays[i] secondi e riprova.
  Se tutti i tentativi falliscono: loga ERROR [ONCHAIN_RETRY] e rilancia.
- Applica a: contract.functions.*.call(), w3.eth.send_raw_transaction()

--- TASK 2.3 — Wait-for-receipt invece di TX_DELAY_SEC ---

Sostituisci il delay fisso `time.sleep(TX_DELAY_SEC)` con:
```python
receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
if receipt.status != 1:
    raise Exception(f"TX revertata: {tx_hash.hex()}")
```
Se timeout (>30s): loga WARNING [ONCHAIN_TIMEOUT] e procedi (fail-open, non bloccare il sistema).

--- TASK 2.4 — Summary report a fine esecuzione ---

Mantieni contatori committed, resolved, errors, skipped durante il main().
Alla fine: `print(f"[ONCHAIN_SUMMARY] Committed: {c}, Resolved: {r}, Errors: {e}, Skipped: {s}")`

--- TASK 2.5 — Verifica integrità contratto (review, no code change) ---

Leggi contracts/BTCBotAudit.sol e verifica:
- L'offset bet_id (+10M inputs, +20M fill, +30M stops) crea collisioni al bet_id N?
  Calcola: quando bet_id raggiunge 10.000.000 i commitHash colliderebbero.
  Con ~10 bet/giorno: quanti anni prima della collisione? Documenta in scripts/results/c2_contract_audit.md.
- gasPrice 30 gwei: adeguato per Polygon PoS? Verifica soglia attuale nella tua KB.
- Il pattern commit-then-reveal è corretto? Il commitHash è calcolato off-chain → rischio front-running
  su Polygon PoS con 2s block time è realistico? Scrivi la valutazione.

REGOLE INVIOLABILI:
- continueOnFail sempre: errore on-chain NON blocca mai il trading
- NON fare git push
- Finisci aggiornando AGENT_HANDOFF.md con DONE per ogni task completato
