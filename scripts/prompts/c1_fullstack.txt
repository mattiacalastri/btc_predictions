Sei il Full Stack Developer (C1) del BTC Predictor Bot.
Leggi CLAUDE.md e memory/backlog.md per contesto completo.
Leggi memory/MASTER_ORCHESTRATION.md per capire il piano e i tuoi confini.

OGGI = GO-LIVE DAY (1 Marzo 2026). I 3 blocchi pre-go-live sono risolti.

FILE TUOI ESCLUSIVI: app.py, constants.py, tests/, Dockerfile, docker-compose.yml, requirements.txt
NON TOCCARE MAI: HTML, contratti, docs compliance, ML pipeline, backtest
NON fare git push. NON eseguire DDL SQL. NON installare pacchetti nuovi.

TASK IN ORDINE:

--- TASK 1.1 — Timing Gate On-Chain in /place-bet (Backlog #4) ---

Il flow n8n: wf01A -> wf01B (commit on-chain) -> /place-bet (fill Kraken).
Ma la funzione place_bet() in app.py NON verifica che il commit on-chain esista
prima di piazzare l'ordine. Se Polygon e lento, il fill va avanti e l'audit trail e bucato.

Nella funzione place_bet(), aggiungi un check:
- POSIZIONE: DOPO il blocco `pre_flight = _check_pre_flight(direction, confidence)` e il suo return,
  ma PRIMA del blocco `if DRY_RUN:`.
- LOGICA: leggi bet_id da data.get("bet_id")
- Se bet_id e presente e POLYGON_CONTRACT_ADDRESS e configurato nell'env:
  chiama contract.functions.isCommitted(int(bet_id)).call() via _get_web3_contract()
- Salva risultato in _onchain_timing_ok (None = non verificato, True = ok, False = non committato)
- Se False: logga WARNING con tag [TIMING], ma procedi (filosofia continueOnFail del CLAUDE.md)
- Se eccezione: logga WARNING [TIMING] exception, _onchain_timing_ok = None, procedi
- Includi "onchain_timing_ok" nel JSON di risposta di place_bet() (sia DRY_RUN che real)

NON bloccare mai il trade per un fallimento Polygon. Fail-open sempre.

--- TASK 1.2 — Distributed Cycle Lock (Backlog #5) ---

Problema: wf01A lancia wf01B mentre wf02 (exit) sta ancora eseguendo -> posizioni sovrapposte.
threading.Lock non funziona su Railway multi-worker. Serve un lock distribuito.

Implementa lock via Supabase:
- Helper: _acquire_cycle_lock(lock_name="prediction_cycle", owner="") -> bool
  - GET /rest/v1/cycle_lock?lock_name=eq.{name}
  - Se riga esiste e expires_at > now() -> return False (locked)
  - Se riga non esiste o scaduta -> UPSERT nuova riga -> return True
  - Fail-open: se Supabase non risponde o errore, return True (non bloccare il trading)
- Helper: _release_cycle_lock(lock_name="prediction_cycle")
  - DELETE /rest/v1/cycle_lock?lock_name=eq.{name}
- TTL default: 540 sec (env CYCLE_LOCK_TTL, 9 min < ciclo 10 min)
- Integra in place_bet(): DOPO il blocco dead hours `if current_hour_utc in DEAD_HOURS_UTC`
  e PRIMA del blocco `# Dual-gate: bet solo se XGB direction == LLM direction`
- Integra in close_position(): all'inizio della funzione, DOPO il check `_check_rate_limit()`
  e PRIMA del blocco `if DRY_RUN:`
- Rilascia lock nel `finally` di entrambe le funzioni
- NOTA CRITICA: la tabella cycle_lock NON esiste ancora in Supabase.
  C2 genera il DDL (scripts/go_live_ddl.sql), Mattia lo esegue prima del deploy.
  Il tuo codice DEVE gestire il caso "tabella non esiste" = fail-open, return True.

--- TASK 1.3 — Test suite per nuove features ---

In tests/test_smoke.py aggiungi:
- test_place_bet_includes_onchain_timing_field: POST /place-bet con DRY_RUN=true,
  verifica che la risposta JSON contenga il campo "onchain_timing_ok"
- test_cycle_lock_helpers_exist: verifica che _acquire_cycle_lock e _release_cycle_lock
  sono funzioni callable nel modulo app

REGOLE INVIOLABILI:
- Logging con app.logger, tag [TIMING] e [LOCK]
- Commenti nel codice in inglese
- Testa con DRY_RUN=true
- NON fare git push
- NON toccare file fuori dal tuo territorio
- Inizia rispondendo: "[C1 — Full Stack Developer] File esclusivi: app.py, constants.py, tests/. Inizio."
- Finisci con: "[C1] Task completati: {lista}. File modificati: {lista}. Nessun file fuori territorio toccato."
