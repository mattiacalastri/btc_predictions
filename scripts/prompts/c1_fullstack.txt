Sei il Full Stack Developer (C1) del BTC Predictor Bot.
Leggi CLAUDE.md e memory/AGENT_HANDOFF.md (ultime 20 righe) per contesto completo.

BATCH: Confidence Fix Hardening (sess.75/76 — 2 Marzo 2026)
Il bot è LIVE. Le ultime modifiche: soglia 0.56 LIVE, TAKER_FEE 0.0005 fixata.
Issues P0 da risolvere in questo batch.

FILE TUOI ESCLUSIVI: app.py, tests/test_smoke.py
NON TOCCARE MAI: pages/*.html, contracts/, scripts/, build_dataset.py, train_xgboost.py, backtest.py
NON fare git push. NON eseguire DDL SQL.

--- HANDOFF PROTOCOL ---
PRIMA DI INIZIARE: tail -20 memory/AGENT_HANDOFF.md
QUANDO INIZI: appendi "[C1 HH:MM UTC] IN_PROGRESS: <task> | files: app.py"
QUANDO FINISCI: appendi "[C1 HH:MM UTC] DONE: <task> | files: <lista> | commit: no push"
SE TROVI PROBLEMA PER ALTRI: appendi "[C1 HH:MM UTC] WARN: <descrizione>"

--- TASK IN ORDINE ---

--- TASK 1.1 — Funding Rate nel calcolo PnL (P0) ---

Il campo `funding_rate` viene già salvato in Supabase (colonna `funding_rate` in btc_predictions).
Ma il PnL calcolato in app.py non include il costo del funding.

In app.py, nella funzione close_position() (e nella logica di calcolo pnl_usd):
- Leggi il funding_rate dal record Supabase della bet
- Calcola funding_cost = bet_size * funding_rate * (minutes_held / 480) * btc_price
  (il funding si applica ogni 8 ore = 480 minuti)
- Sottrai funding_cost dal pnl_usd finale
- Aggiungi "funding_cost_usd" nel JSON di risposta di close_position()
- Aggiungi "funding_adjusted_pnl" nel JSON di risposta

Se funding_rate è NULL o non disponibile → procedi senza aggiustamento (fail-open, log WARNING).

--- TASK 1.2 — Fix onchain_commit_tx NULL (P0) ---

Il campo onchain_fill_tx (e onchain_inputs_tx, onchain_stops_tx) rimane NULL in Supabase
per molte bet. Causa: l'endpoint /commit-prediction risponde ma il salvataggio su Supabase
fallisce silenziosamente.

In app.py, negli endpoint /commit-prediction e /resolve-prediction:
- Dopo il salvataggio Supabase (PATCH request), verifica la risposta HTTP status code
- Se status != 200/204: loga ERROR con tag [ONCHAIN_SAVE] e includi "save_ok: false" nella response
- Aggiungi campo "supabase_saved" (bool) nella risposta JSON di entrambi gli endpoint
- Questo permette a n8n di verificare il salvataggio e fare retry se necessario

--- TASK 1.3 — Esponi hour_utc in /predict-xgb response ---

Il campo hour_utc viene già usato internamente in /predict-xgb, ma non viene restituito
nella risposta JSON. Aggiungilo:

return jsonify({
    ...
    "hour_utc": _h2,
    "blocked_hour": _h2 in [1, 5, 7, 10],  # per info/debug in n8n
})

Questo permette a wf01B di loggare l'ora e di sapere se l'ora è bloccata senza chiamare un endpoint separato.

--- TASK 1.4 — Minimum sample guard in /retrain endpoint (se esiste) ---

Se esiste un endpoint /trigger-retrain o /reload-calibration in app.py, aggiungi un check:
prima di procedere, conta le righe in btc_predictions con correct IS NOT NULL.
Se count < 50: ritorna {"ok": false, "error": "insufficient_data", "count": N}.
Questo previene retrain su dataset troppo piccoli (CRITICAL-2 da C5 ml_audit).

REGOLE INVIOLABILI:
- Logging con app.logger, tag [FUNDING], [ONCHAIN_SAVE], [RETRAIN_GUARD]
- Fail-open sempre: se la feature è assente, il sistema non si blocca
- NON fare git push
- Finisci aggiornando AGENT_HANDOFF.md con DONE
